# 前端工程简史

## 前后端分离

分别从开发、测试和部署 3 个方面分析前后端分离要解决哪些问题。

### 开发

- 静态资源的处理 - 这类资源在浏览器的呈现方式是静态的，不需要服务器做任何处理。
  - JavaScript、css、图片等
- 动态资源的处理
  - HTML模板 - 除非项目不需要任何服务器端渲染的 SPA，否则仍然不可避免地要处理前后端最难解耦的 HTML 模板。
    - SPA 项目 - 这类项目中不存在 HTML 模板的概念，所有的 HTML 实体内容均由 JavaScript 在浏览器下生成。所以 SPA 项目中可以将 html 文件作为静态文件处理。
    - HTML 模板由服务器端部署的项目 - 这类项目最终的 HTML 模板需要与服务器端代码一同打包部署。
    - 大前端项目 - 这类项目中前端工程师负责与客户端相关的所有文件，包括静态文件与 HTML 模板，这是最理想的模式。

可以看出不论是 SPA 还是大前端，开发阶段的前后端分离都比较容易实施。但我们不得不面对的一个现实是，目前国内的Web产品绝大多数是第二种项目类型。这也是最难以实现完全前后端分离的项目。

对于 HTML 模板由服务器端部署的项目，前后端分离要解决 3 个问题。

- HTML模板引擎的支持。
- HTML模板的初始数据。
- 各种异步数据接口的数据。

### 测试

- 单元测试 - 这个阶段前后端工程师的测试是独立的
- 集成测试 - 这个阶段前后端的代码进行整合

前后端分离首先要解决的是集成测试阶段的问题及时定位，前端工程师负责所有与用户直接接触的功能和逻辑，后端工程师的产出并不与用户直接接触，前端工程师更容易定位用户层面的问题。

理想情况下，服务器端单元测试覆盖率达标并且测试通过后，接口是不应该存在逻辑性错误的。如果客户端出现因数据引起的问题，通常是因为客户端的 JavaScript 逻辑存在问题，比如一些 side effect (临界问题〉没有处理好。

### 部署

前后端分离在部署阶段要解决的问题是静态资源和动态资源的分离部署。

- 大前端模式
  - 将JS、css、图片等静态资源部署到静态文件服务器
  - HTML 模板文件与中间层的 Node.js 代码一同部署到 Web 服务器
- SPA 项目 - 由于 SPA 中的 html 文件不需要在服务器端渲染，因此其理论上可以与其他静态资源一同部署到静态文件服务器 。但是有一个问题是，不能令浏览器将 html 文件强制缓存到本地。否则即使更新了 html 文件，也会由于缓存策略而无法获取最新资源。解决这个问题的办法有两种，分别如下：
  - 分别为 html 文件与其他静态资源设置不同的缓存策略。html 文件可以使用协商缓存策略(状态码 304)，其他静态资源使用强缓存策略(状态码“200(from cache))”。
  - 使用一刀切的方案，所有静态资源均使用协商缓存策略。
- HTML 模板由服务器端部署项目
  - 静态资源部署到静态文件服务器。
  - HTML 模板文件编写完成之后由前端工程师通过 SVN、Git 等版本管理工具同步到代码仓库，后端工程师拉取最新代码后，将模板文件与服务器端逻辑代码一同部署。

### 前后端分离形态

- 开发层面
  - ES规范与浏览器兼容性不一致。
  - css 的弱编程能力。
  - 资源定位。
  - 图片压缩/base64 内嵌/CSS Sprites。
  - 模块依赖分析和压缩打包。
- 协作层面
  - JavaScript部分逻辑依赖接口API。
- 部署层面
  - 部分资源需要借助后端工程师部署。

本地服务器与构建功能相结合，可以提供动态构建、浏览器自动刷新等功能，这进一步提高了前端工程师的工作效率。综上所述，本地服务器须具备以下功能：

- Mock 服务 - 如果团队具备统一的云 Mock 平台，本地服务器可以不提供 Mock 服务。但如果需要支持 SSR，则必须提供本地 Mock 服务。
- 支持 SSR - 前提是本地服务器与线上服务器使用相同的编程语言。
- 动态构建，浏览器自动刷新。

### 静态资源和动态资源分离部署

将渲染 HTML 的工作全部交给前端，也就是目前业界流行的 SPA (单页应用)。前端渲染的优点如下：

- 前端掌控路由，与传统的服务器端路由相比用户体验更佳。
- 可移植、可离线使用。
- 服务器端提供的是干净的数据接口，具备高度的可复用性。
- HTML 资源作为静态资源，易于部署。
- 前端工程师与后端工程师可以使用 Git、SVN 等工具分别维护独立的源代码，无须耦合。

前端渲染的缺点是不利于 SEO (搜索引擎优化)。

### 前踹工程化的3个阶段

- 本地工具链一一工程化不等同于工具化
  - 前端工程化是一系列工具和规范的组合，规范为蓝本，工具为实现。
    - 项目文件的组织结构，比如使用目录名称区分源文件和目标文件。
    - 源代码的开发范式，比如使用既定的模块化方案。
    - 工具的使用规范，比如工程化自身的配置规范。
    - 各阶段环境的依赖，比如部署功能的实现需要目标服务器提供 SSH 权限。
- 管理平台一一进一步淡化差异、加深规范
  - 环境差异性的影响，比如操作系统类型、版本、内核等。这些因素会在一定程度上影响构建产出代码的一致性。
    - 淡化环境差异性，保证构建产出的一致性。
    - 权限集中管理，提高安全性。
    - 项目版本集中管理，便于危机处理，比如版本回滚等。
- 持续集成一一前踹工程化的目标是融入整体

## 工程化方案架构

### webpack

- 工作流管理工具，比如 Grunt、Gulp。
  - Grunt、Gulp之类工作流管理工具本身不提供任何具体功能，所有的构建、部署等功能均由对应的插件提供。这便于项目各环节工作流程的控制。
- 构建工具，比如 webpack、rollup。
  - webpack 在提供足够多的构建功能的同时兼具性能优化，比如对构建产出文件的体积进行监控、其v2版本引入的 Tree Shaking机制等。这也是我们选择 webpack 作为构建内核的原因之一。rollup也是一款非常优秀的构建工具，但由于起步较晚，目前生态还不完整。
- 整体解决方案，比如 FIS、WeFlow。
  - FIS 是一套比较完整的前端工程化方案，它具备构建、部署、Mock 服务等基本功能，但其构建功能对于目前市场较流行的技术支持度不是很理想，需要编写插件实现。而且其生态圈不够庞大，插件数量和质量均堪忧。此外，FIS 诞生的初始目标是解决百度团队的内部需求。

### 工程化万案的整体架构

![](http://cdn-blog.liusixin.cn/WX20180810-153504@2x.png)

- 暴露给用户层的有两种接口：命令行调用各功能模块的接口和配置接口。
- 平台层分为4个功能模块：脚手架、本地服务器、构建以及部署模块。
- 内核层是各个功能模块的内核，脚手架使用 Yeoman，本地服务由 Node.js 的 Express 框架承载，构建功能模块围绕 webpack 打造，部署基于 SSH 协议实现。
- 以上所有的功能实现均是建立在 Node.js 平台上的。

> Boi 是一款开源的前端工程化方案：[https://github.com/boijs/boi](https://github.com/boijs/boi)

### 功能规划

平台层分为4个功能模块。

- 以 Yeoman 为内核的脚手架。
- 以 Express 承载的本地服务器。
- 以 webpack 为内核的构建系统。
- 基于 SFTP 协议的远程部署功能。

#### 1. 命令行工具

得益于庞大的生态圈，使用 Node.js 开发命令行工具并不是一件难事，我们可以借助优秀的辅助工具完成，比如 commander.js。

> commander 是一个实现命令行交互的 Node.js模块，更多使用细节读者可以参考 commander.js 的官方文档。

#### 2. 构建功能规划

- ES 规范的转译。
- css预编译器支持。
- PostCSS 处理 hack 后缀。
- 自动创建 CSS Sprites 图。
- 图片压缩。
- 小体积图片 base64 内嵌。
- JavaScript 模块化规范支持。

除以上功能以外，针对不同的缓存策略可以支持增量更新与覆盖更新构建。

#### 3. 环境区分

一个前端项目的迭代周期自始至终需要经历3个阶段：开发、测试和部署上线。

- dev - 开发环境。
- testing - 测试环境。
- prod - 生产环境。

### 设计原则

- 规范设计原则一一用户至上
- 架构设计原则一一扩展至上
  - 前端资源以及技术选型的多样性，令可扩展性对于前端工程化方案来说尤为重要。我们在设计工程化方案架构时，应当秉持“内核轻量、扩展丰富”的原则。比如 webpack 本身不提供任何具化的方案，而是开放丰富的配置和扩展 API 供开发者封装和扩展自己的构建方案。