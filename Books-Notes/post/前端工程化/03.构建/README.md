# 构建

前端资源的构建处理需要考虑 Web 应用的性能因素。比如开发阶段使用模块化开发，每个模块有独立的 JS/CSS/图片等文件。如果不做处理将每个文件独立上线的话，无疑会增加客户端 HTTP 请求的数量，从而影响 Web 应用的性能和用户体验。针对诸如此类的问题，构建还需要包括以下功能：

- 依赖打包一一分析文件依赖关系，将同步依赖的文件打包在一起，减少 HTTP 请求数量。
- 资源嵌入一一比如小于 10KB 的图片编译为 base64 格式嵌入文档，减少一次 HTTP 请求。
- 文件压缩一一减小文件体积，缩短请求时间。
- hash 指纹一一通过给文件名加入 hash 指纹，以应对浏览器缓存策略。

html 文件与 JS、CSS、图片等资源是引用与被引用关系。被引用的资源经过构建后通常有以下改动：

- 域名/路径改变一一开发环境与线上环境的域名肯定是不同的，不同类型的资源甚至部署于不同的 CDN 服务器上。
- 文件名改变一一经过构建之后文件名被加上 hash 指纹，内容的改动导致 hash 指纹的改变。

> 对于 html 文件的构建工作需要注意在其引用资源 URL 改变时同步更新，这个功能通常被称为**资源定位**。

综上所述，构建需要解决的问题可以归纳为以下 3 类:

- 面向语言
- 面向优化
- 面向部署

## 增量更新与缓存

合理利用缓存是 Web 性能优化的必要手段，前端工程师所接触的主要是针对客户端浏览器的缓存策略，客户端的缓存可以分为以下两种。

- 利用本地存储，比如 `LocalStorage`、`SessionStorage` 等。
- 利用 HTTP 缓存策略，其中又分为强制缓存与协商缓存。

增量更新是目前大部分团队采用的缓存更新方案，结合 HTTP 强制缓存策略，既能够保证用户在第一时间获取最新资源，又可以减少网络资源消耗，提高 Web 应用程序的执行速度。前端工程体系在此中的作用如下：

- 构建产出文件 hash 指纹，这是实现增量更新的必要条件。
- 构建更新 html 文件对其他静态资源的引用 URL。

### HTTP 缓存策略

#### 1. Expires 和 max-age

`Expires` 和 `max-age` 是强制缓存策略的关键信息，两者均是响应首部信息的。

- `Expires` - HTTP 1.0 加入的特性
  - 通过指定一个明确的时间点作为缓存资源的过期时间，在此时间点之前客户端将使用本地缓存的文件应答请求，而不会向服务器发出实体请求(在浏览器调试面板中可以看到此请求并且状态码为 200)。
  - `Expires` 有一个致命的缺陷是：它所指定的时间点是以服务器为准的时间，但是客户端进行过期判断时是将本地的时间与此时间点对比。也就是说，如果客户端的时间与服务器存在误差。
  - 针对这个问题，HTTP 1.1 新增了 `Cache-control` 首部信息以便更精准地控制缓存。常用的 `Cache-control` 信息有以下几种。
    - `no-cache` 和 `no-store`
    - `public` 和 `private`
    - `max-age` - 指定的是缓存的时间跨度，而非缓存失效的时间点，不会受到客户端与服务器时间误差的影响。所以，与 `Expires` 相比，`max-age` 可以更精确地控制缓存，并且比 `Expires` 有更高的优先级。

![](http://cdn-blog.liusixin.cn/WX20180810-174539@2x.png)

#### 2. Etag 和 If-none-match

`Etag` 是服务器为资源分配的字符串形式唯一性标识，作为响应首部信息返回给浏览器。浏览器在 `Cache-control` 指定 `no-cache` 或者 `max-age` 和 `Expires` 均过期之后，将 `Etag` 值通过 `If-none-match` 作为请求首部信息发送给服务器。服务器接收到请求之后，对比所请求资源的 `Etag` 值是否改变，如果未改变将返回 `304 Not Modified`, 并且根据既定的缓存策略分配新的 `Cache-control` 信息:如果资源发生了改变，则会返回最新的资源以及重新分配的 `Etag` 值。

![](http://cdn-blog.liusixin.cn/WX20180810-174704@2x.png)

如果强制浏览器使用协商缓存策略，需要将 `Cache-control` 首部信息设置为 `no-cache`，这样便不会判断 `max-age` 和 `Expires` 过期时间，从而每次资源请求都会经过服务器对比。

### 覆盖更新与增量更新

覆盖更新与增量更新都是建立在启用浏览器强制缓存策略的前提下的。增量更新是目前被业界广泛使用的前端静态资源更新策略，普遍的实现方案是通过为文件名添加 hash 指纹。覆盖更新的缺陷较多且没有较好的解决方案，目前己逐渐被淘汰。

增量更新策略将原本作为参数值的 hash 指纹作为资源文件名的一部分并且删除用于更新的 url 参数。比如:

```html
<head>
  <link rel="stylesheet" href="main.858d42a1.css" />
</head>
```

在静态资源使用增量更新策略的前提下，可以将静态资源先于动态 HTML 部署，此时静态资源没有引用入口，不会对线上环境产生影响;动态 HTML 部署后即可在第一时间访问己存的最新静态资源。这样便解决了覆盖更新部署同步性的问题。另外，增量更新修改了资源文件名，不会覆盖己存的旧版本文件，运维人员进行回滚操作时只需回滚 HTML 即可。这样不仅优化了版本控制，而且还可以支持多版本共存的需求。

### 按需加载与多模块架构场景下的增量更新

多模块架构指的是存在多个互不干扰的模块体系，这些模块体系可能存在于同一页面中，也可能存在于两个独立页面。对于按需加载需求和在多模块架构场景下实现增量更新，需要考虑以下几个问题:

- 同步模块的修改对异步文件和主文件 hash 指纹产生的影响
  - 假设一个单页面项目的模块结构
  - 主模块 `main.app.js`
  - 同步模块 `module.sync.js`，构建后与主模块合并为主文件 `main.app.[hash].js`，同步加载。
  - 异步模块 `module.async.js`，单独构建为异步文件 `app.async.[hash].js`，按需加载。
  - 构建输出的文件`[hash]`值是经过 `md5` 计算所得的，参与计算的模块内容改动后必然影响计算后的结果。同步模块 `module.sync.js` 的内容作为计算因子参与主文件的 hash 指纹计算，并未参与异步文件 hash 指纹的计算。所以可以确定的是，同步模块的修改影响主模块的 hash 指纹，对异步文件无影响。
- 异步模块的修改对主文件 hash 指纹产生的影响。
  - 异步模块的修改不仅仅影响其对应异步文件的 hash 指纹，主文件的 hash 指纹也必须同步修改，这样才能保证用户得到最新的异步文件。

### webpack 实现增量更新构建方案

webpack 本身具备计算 hash 的功能，但是如果要搭建一套完整的增量更新构建方案还需要在其配置上花费一些功夫。

#### 1. hash 与 chunkhash

- hash
  - webpack 的 compilation 对象代表某个版本的资源对应的编译进程。每次检测到项目文件有改动就会创建一个 compilation，进而能够针对改动生产全新的编译文件。
  - compilation 对象不是针对单个文件的，而是针对项目中所有参与构建的文件的。
  - 换句话说，只要任何一个文件内容有改动，compilation 对象便会改变，作为 compilation 的 hash 值也就相应地发生改变。任何一个文件的改动都会影响所有资源的缓存。

```js
output: {
  filename: '[name].[hash:8].js';
}
```

那么构建输出的不论是同步文件还是异步文件均拥有相同的 hash 指纹，这显然不是合理的方案，hash 并不适用于增量更新的构建场景。

- chunkhash

```js
output: {
  filename: '[name].[chunkhash:8].js';
}
```

主文件与异步文件的 hash 指纹不同。

#### 2. contenthash

contenthash 是解耦 js 与 css 文件 hash 指纹的关键。

## 资源定位

- 原始形态：一切都很简单
  - 以前 Web 项目普遍的部署方式是将 JS、CSS、图片等静态资源与服务器端代码部署在相同的路径。
- 内容分发网络：推动进化的车轮
  - CDN (ContentDeliveryNetwork，内容分发网络)是一种部署策略，包括分布式存储、负载均衡、内容管理等模块。CDN 的实现细节并不属于前端的范畴，但是如果 Web 站点使用了 CDN 部署策略，那么便会影响到资源定位的处理。
  - 实现此功能的一个重要前提是将静态资源部署到己接入 CDN 解析服务的专属服务器上，而这类服务器通常与 Web 主页面处于不同的域名下。这样做的主要目的是为了充分利用浏览器的并发请求能力，提高页面的加载速度。同时，独立域名的静态资源请求不会携带主页面的 cookie 等数据，这样进一步加快了网络访问。
- 前后踹分离：将责任交给前踹
  - 前后端分离将 View 层的开发和部署工作全部交给了前端开发人员。不论是完全前端渲染的 SPA，还是支持服务器端渲染的大前端，得益于 Node.js 的支持以及构建工具的发展，资源定位问题的解决均可由前端工程师熟悉的 JavaScript 语言驱动。
  - 再回顾一下由服务器端负责解决资源定位问题所依赖的条件。
    - 硬性条件：静态资源构建及部署之后的完整地址，包括 CDN 服务器路径和携带 hash 指纹的文件名。
    - 附加条件：沟通成本。

### webpack 的逆向注入模式

webpack 将 JS 视为一切资源的入口(包括 HTML)，不论是直接还是间接，只要与 entry 配置的 js 文件存在引用关系的资源都会参与构建。

HTML 在 webpack 中与 css 一样属于“次等公民”，可以使用 `html-webpack-plugin` 编译 HTML 井且将其导出为独立的文件。

#### 1. html-loader 和 html-webpack-plugin