## 执行上下文

执行上下文可以理解为当前代码的运行环境。

JavaScript 中的运行环境主要包括以下三种。

- 全局环境：代码运行起来后会首先进入全局环境
- 函数环境：当函数被调用执行时，会进入当前函数中执行代码。
- `eval` 环境：不建议使用，这里不做介绍。

JavaScript 引擎会以栈的方式来处理它们，这个栈，即函数调用钱。函数调用栈规定了 JavaScript 代码的执行顺序。栈底永远都是全局上下文，栈顶则是当前正在执行的上下文。当代码在执行过程中遇到以上几种情况时，都会生成一个执行上下文并放入函数调用栈中，处于栈顶的上下文执行完毕之后，会自动出栈。

为了更加清晰地理解整个过程，通过几个实例来了解函数调用栈的执行规则。

```js
var color = 'blue';

function changeColor() {
  var anotherColor = 'red';

  function swapColors() {
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
  }
  swapColors();
}

changeColor();
```

![](http://cdn-blog.liusixin.cn/WX20180806-145758@2x.png)

> 注意:函数执行过程中遇到 `return` 能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。

再看一个例子：

```js
function f1(){
  var n = 999;
  function f2() {
    alert(n);
  }
  return f2;
}
var result = f1();
result(); // 999
```

这是一个简单的闭包例子，整个例子具有一定的迷惑性。但是我们只需要根据 “函数执行时才会创建执行上下文” 这一原则来理解，那么这段代码执行时的函数调用枝顺序就会 比较清晰了。

- 第一步，仍然是全局上下文先入栈
- 第二步，全局代码在执行过程中，遇到了 `f1()` 函数，执行 `var result = f1();`，因此f1会创建对应的执行上下文并入栈
- 第三步，在 f1 的可执行代码中，虽然声明了一个函数f2，但是并没有执行任何函数，因此也就不会产生别的上下文，代码执行结束后， f1 自然会出栈。
- 第四步，f1 出栈之后，继续执行全局上下文的代码，这个时候遇到了 `result()`, `result()`会创建一个新的上下文，因此这个时候 result 的上下文入栈
- 第五步，这个 `result()` 其实就是在 f1 中声明的函数 f2，因此这个时候会执行 f2 中的代码。由于在f2中没有产生新的上下文，因此执行完毕后直接出栈。

![](http://cdn-blog.liusixin.cn/WX20180806-150308@2x.png)

### 生命周期

> 我们知道，当一个函数调用时，一个新的执行上下文就会被创建。一个执行上下文的生命周期大致可以分为两个阶段: 创建阶段和执行阶段。

- 创建阶段
  - 执行上下文会分别创建变量对象，确认作用域链，以及确定 this 的指向。
- 执行阶段
  - 创建阶段之后，就开始执行代码，这个时候会完成变量赋值、函数引用，以及执行其他可执行代码。

![](http://cdn-blog.liusixin.cn/WX20180806-151229@2x.png)